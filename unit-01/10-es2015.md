#### [⇐ Previous](./09-intermediate-oop.md) | [Table of Contents](./../readme.md) | [Next ⇒](./11-project.md)

# EcmaScript2015

### Objectives:

By the end of this chapter - you should be able to

- Use arrow functions and explain the difference between them and the `function` keyword
- Utilize ES2015 operators like spread and rest
- Refactor code to use `let` and `const` and explain the implications of using both
- Explain what the the `class` keyword in ES2015 does

### Let and Const

ES2015 brings us some new words to declare variables along with a new kind of scope. So far we have only seen `global` and `function` scope, `let` gives us access to `block` scope. You can think of blocks as `{}` that are not part of an object or function definition. Blocks exist in `if` statements, `for/while` loops, `switch` statements and `try/catch` blocks. Here are some examples

```javascript

let instructor = "Elie"
if(instructor === "Elie"){
    let anotherInstructor = "Tim"
}

for(let i=0; i<5; i++){
    setTimeout(function(){
        console.log(i)
    },1000)
}

```

ES2015 also gives us another keyword `const` which allows us to create constants (think of them like variables that can not be modified)

```javascript
const favoriteFood = "Pad Thai"
const favoriteFood = "Pad See Ew"
// Uncaught TypeError: Identifier 'favoriteFood' has already been declared(…)
const person;
// Uncaught SyntaxError: Missing initializer in const declaration
```

### Template Strings

ES2015 gives us string interpolation using back ticks (``) and adding our variables in a `${}`. Here is an example:

```javascript

`Now we can do string interpolation like ${1+1}`;

var person = "Elie"

`My name is ${person}`;
```

### Default Parameters

Another nice feature is the ability to add default values to parameters in our functions

```javascript

// OLD - causes unintended issues because 0 is falsey!

function add(a,b){
    a = a || 12
    b = b || 13
    return a+b
}

add() // 25
add(0) // 25 - WHY IS THIS??
add(0,0) // 25 - WHAT IS HAPPENING??

// NEW
function add(a=12,b=13){
    return a+b
}

add() // 25
add(0) // 13 - CORRECT!
add(10,10) // 20
```

You can read more [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters)

### Arrow Functions

As an alternative to the keyword `function`, es2015 gives us a new option called `arrow functions`. These functions are denoted by the `=>` character(s). While they are very similar to the `function` keyword. Arrow functions have a few key differences.

- If the arrow function is all on 1 line - an implicit `return` is added (you do not need the keyword `return`).
- If the arrow function is on more than one line, `{}` must be used (just like a regular `function`)
- Arrow functions are **always** anonymous
- Arrow functions lexically bind the `this` value. What does that mean? From MDN: Until arrow functions, every new function defined its own this value (a new object in case of a constructor, undefined in strict mode function calls, the context object if the function is called as an "object method", etc.). This proved to be annoying with an object-oriented style of programming.

Let's see some examples:

```javascript
var arr = [1,2,3,4];

arr.map(function(va){
    return val*2;
})

arr.map(val => val *2)
```

```javascript
var obj = {
    firstName: "Elie",
    sayHi: function(){
        setTimeout(function(){
            console.log()
        },1000)
    }
}
```

You can read more [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

### Rest / Spread

ES2015 gives us two operators `rest` (think of it like the "rest" of the arguments) and `spread` (which you can think of as - spread an array into a set of comma separated values). The `rest` operator is used as a parameter to a function and the spread operator is used outside of function parameters. Here are some examples:

```javascript
function data(a,b,...c){
    console.log(a,b,c);
}

data(1,2,3,4,5) // 1, 2, [3,4,5]

var arr = [1,2,3,4]
function addFourNumbers(a,b,c,d){
    return a+b+c+d
}
addFourNumbers(...arr)
```

You can read more about spread [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) and rest [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters)

### Object Shorthand notation + Destructuring Assignment  

ES2015 gives us quite a few enhancements on objects which allow us to write more concise code with less repetition. Let's see what that looks like:

```javascript
var obj = {
    firstName: "Elie",
    sayHi: function(){
        return "Hello from ES5!"
    }
    sayBye(){
        return "Bye from ES2015!"
    }
}

var person = "Elie"
var es5Object = {person: person}
es5Object // {person: "Elie"}

var es2015Object = {person}
es2015Object // {person: "Elie"}
```

ES2015 also gives us access to destructuring objects and arrays. From MDN - The destructuring assignment syntax is a JavaScript expression that makes it possible to extract data from arrays or objects into distinct variables. 

```javascript
var obj = {
    a:1,
    b:2,
    c:3
}

var {a,b,c} = obj;

a // 1
b // 2
c // 3
```

You can read more about it [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

### Array destructuring 

In the same way that we can destructure objects, we can also destructure arrays (which are really just a special type of an object).

```javascript
var arr = [1,2,3,4]
var [a,b,c,d] = arr

a // 1
b // 2
c // 3
d // 4

var [first,second] = [1,2]

first // 1
second // 2

var a = 1;
var b = 2;

[a, b] = [b, a];
```

You can read more about it [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

### Class syntax

Although this addition to the language is not widely loved by the community, it is important to understand because modern frameworks like React and Angular 2 use it quite frequently. All that this syntax does is obfuscate constructor functions and prototype properties/methods. There is nothing new going on here - it is just a layer of abstraction. Let's see what this looks like in ES5:

```javascript
function Person(firstName, lastName){
    this.firstName = firstName;
    this.lastName = lastName;
}

Person.prototype.sayHi = function(){
    return this.firstName + " " + this.lastName + " says hello!";   
}

Person.isPerson(person){
    return person.constructor === Person;
}
```

Here is what an ES2015 Implementation looks like:

```javascript
class Person {
    constructor(firstName, lastName){
        this.firstName = firstName;
        this.lastName = lastName;
    }
    sayHi(){
        return `${this.firstName} ${this.lastName} says hello!`;
    }
    static isPerson(person){
        return person.constructor === Person;
    }
}
```

The function called `constructor` MUST be named that way (since that is what is run when the `new` keyword is used). If you just try to run `Person()` you will get a TypeError with the message that "Class constructor Person cannot be invoked without 'new'".

If we want to add functions directly on the "class" (which is really a function) - we use the word `static`.

You can read more about classes [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)

### More Advanced concepts

Later on in this course we will learn more about some more advanced ES2015 concepts - you can read more about them here:

- [Iterators and Generators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)
- [Map/WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
- [Set/WeakSet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/set)

### Exercise

Complete the [ES2015 Exercise](https://github.com/rithmschool/prework_exercises/tree/master/es2015_exercise)

### Additional Resources

#### [⇐ Previous](./08-prototypes.md) | [Table of Contents](./../readme.md) | [Next ⇒](./10-project.md)
